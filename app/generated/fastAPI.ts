/**
 * Generated by orval v7.8.0 🍺
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import { faker } from "@faker-js/faker";

import { http, HttpResponse, delay } from "msw";

export interface BearerResponse {
  access_token: string;
  token_type: string;
}

export type BodyAuthJwtLoginAuthJwtLoginPostGrantType = string | null;

export type BodyAuthJwtLoginAuthJwtLoginPostClientId = string | null;

export type BodyAuthJwtLoginAuthJwtLoginPostClientSecret = string | null;

export interface BodyAuthJwtLoginAuthJwtLoginPost {
  grant_type?: BodyAuthJwtLoginAuthJwtLoginPostGrantType;
  username: string;
  password: string;
  scope?: string;
  client_id?: BodyAuthJwtLoginAuthJwtLoginPostClientId;
  client_secret?: BodyAuthJwtLoginAuthJwtLoginPostClientSecret;
}

export interface BodyReadFileUploadPost {
  files: Blob[];
}

export interface BodyResetForgotPasswordAuthForgotPasswordPost {
  email: string;
}

export interface BodyResetResetPasswordAuthResetPasswordPost {
  token: string;
  password: string;
}

export interface BodyVerifyRequestTokenAuthRequestVerifyTokenPost {
  email: string;
}

export interface BodyVerifyVerifyAuthVerifyPost {
  token: string;
}

export interface CompositeDefinition {
  parent: Definition;
  children?: CompositeDefinition[];
}

export type DeductionUid = string | null;

/**
 * 演繹.
 */
export interface Deduction {
  uid?: DeductionUid;
  created: string;
  updated: string;
  text: string;
  premises?: Proposition[];
  conclusion: Proposition;
  /** 結論の正しさ */
  valid: boolean;
}

export type DeductionMapperUid = string | null;

/**
 * LabelのMapper.
 */
export interface DeductionMapper {
  uid?: DeductionMapperUid;
  created: string;
  updated: string;
  valid: boolean;
  text: string;
}

/**
 * 演繹パラメータ.
 */
export interface DeductionParam {
  txt: string;
  conclusion_id: string;
  premise_ids: string[];
  valid?: boolean;
}

/**
 * 演繹統計.
 */
export interface DeductionStatistics {
  n_src: number;
  n_dest: number;
  n_axiom: number;
  /** 先頭の数 */
  n_leaf: number;
  max_axiom_dist: number;
  max_leaf_dist: number;
}

export type DefinitionUid = string | null;

/**
 * 定義モデル.
 */
export interface Definition {
  uid?: DefinitionUid;
  created: string;
  updated: string;
  term: KnowdeTmpDefinitionTermDomainTerm;
  sentence: Sentence;
  deps?: KnowdeTmpDefinitionTermDomainTerm[];
}

/**
 * 定義パラメータ.
 */
export interface DefinitionParam {
  name: string;
  explain: string;
}

/**
 * 依存関係の統計.
 */
export interface DepStatistics {
  /** 依存元数 */
  n_src?: number;
  /** 依存先数 */
  n_dest?: number;
  /** 最大root距離 */
  max_root_dist?: number;
  /** 最大leaf距離 */
  max_leaf_dist?: number;
}

export type DetailViewDetail = CompositeDefinition | null;

/**
 * show definition composite.
 */
export interface DetailView {
  detail?: DetailViewDetail;
}

/**
 * for fastapi schema.
 */
export interface EdgeData {
  source: string;
  target: string;
}

export type EntryElementIdProperty = string | null;

/**
 * namespace用のhashableな表現.
 */
export interface Entry {
  name: string;
  element_id_property?: EntryElementIdProperty;
  uid: string;
}

export type ErrorModelDetailAnyOf = { [key: string]: string };

export type ErrorModelDetail = string | ErrorModelDetailAnyOf;

export interface ErrorModel {
  detail: ErrorModelDetail;
}

export type GraphDataGraph = { [key: string]: unknown };

export type GraphDataNodesItem = { [key: string]: string };

/**
 * for fastapi schema.
 */
export interface GraphData {
  directed: boolean;
  edges: EdgeData[];
  graph: GraphDataGraph;
  multigraph: boolean;
  nodes: GraphDataNodesItem[];
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type KAdjacencyWhen = string | null;

export type KAdjacencyStats = KStats | null;

/**
 * 周辺情報も含める.
 */
export interface KAdjacency {
  center: Knowde;
  when?: KAdjacencyWhen;
  details?: Knowde[];
  premises?: Knowde[];
  conclusions?: Knowde[];
  refers?: Knowde[];
  referreds?: Knowde[];
  stats?: KAdjacencyStats;
}

export type KStatsScore = number | null;

/**
 * 知識の関係統計.
 */
export interface KStats {
  n_detail: number;
  n_premise: number;
  n_conclusion: number;
  n_refer: number;
  n_referred: number;
  dist_axiom: number;
  dist_leaf: number;
  score?: KStatsScore;
}

export type KnowdeTerm = KnowdePrimitiveTermTerm | null;

/**
 * 知識の最小単位.
 */
export interface Knowde {
  sentence: string;
  uid: string;
  term?: KnowdeTerm;
}

export type NameSpaceRoots = { [key: string]: Entry };

/**
 * リソースの分類.
 */
export interface NameSpace {
  g?: GraphData;
  roots_: NameSpaceRoots;
  user_id: string;
}

export interface OAuth2AuthorizeResponse {
  authorization_url: string;
}

/**
 * ORDER BY句.

weightと項目の合計値(score)でソートできる
他のスコア算出方法についてはペンディング
 */
export interface OrderBy {
  n_detail?: number;
  n_premise?: number;
  n_conclusion?: number;
  n_refer?: number;
  n_referred?: number;
  dist_axiom?: number;
  dist_leaf?: number;
  desc?: boolean;
}

/**
 * クエリのページング.
 */
export interface Paging {
  /** */
  page?: number;
  /** */
  size?: number;
}

export type PropositionUid = string | null;

/**
 * 命題.
 */
export interface Proposition {
  uid?: PropositionUid;
  created: string;
  updated: string;
  text: string;
}

/**
 * interface用.
 */
export interface PropositionParam {
  text: string;
}

/**
 * 結論を置換するCLIパラメータ.
 */
export interface ReplaceConclusionAPIParam {
  conclusion_uid: string;
}

/**
 * 前提を置換するAPIパラメータ.
 */
export interface ReplacePremisesAPIParam {
  premise_uids: string[];
}

export type ResourceMetaPublished = string | null;

export type ResourceMetaPath = string[] | null;

export type ResourceMetaUpdated = string | null;

export type ResourceMetaTxtHash = number | null;

/**
 * リソースメタ情報.
 */
export interface ResourceMeta {
  title: string;
  authors?: string[];
  published?: ResourceMetaPublished;
  urls?: string[];
  path?: ResourceMetaPath;
  updated?: ResourceMetaUpdated;
  txt_hash?: ResourceMetaTxtHash;
}

/**
 * リクエスト用.
 */
export type ResourceMetas = ResourceMeta[];

export type SentenceUid = string | null;

export interface Sentence {
  uid?: SentenceUid;
  created: string;
  updated: string;
  /** @maxLength 128 */
  value: string;
}

/**
 * 統計付き演繹.
 */
export interface StatsDeduction {
  deduction: Deduction;
  stats: DeductionStatistics;
}

/**
 * 統計付き演繹リスト.
 */
export interface StatsDeductions {
  values?: StatsDeduction[];
}

/**
 * 統計付き定義.
 */
export interface StatsDefinition {
  definition: Definition;
  statistics: DepStatistics;
}

/**
 * リストの統計付き定義.
 */
export interface StatsDefinitions {
  values?: StatsDefinition[];
}

export type UserCreateIsActive = boolean | null;

export type UserCreateIsSuperuser = boolean | null;

export type UserCreateIsVerified = boolean | null;

/**
 * 作成.
 */
export interface UserCreate {
  email: string;
  password: string;
  is_active?: UserCreateIsActive;
  is_superuser?: UserCreateIsSuperuser;
  is_verified?: UserCreateIsVerified;
}

/**
 * 読み取り.
 */
export interface UserRead {
  id: string;
  email: string;
  is_active?: boolean;
  is_superuser?: boolean;
  is_verified?: boolean;
}

export type UserUpdatePassword = string | null;

export type UserUpdateEmail = string | null;

export type UserUpdateIsActive = boolean | null;

export type UserUpdateIsSuperuser = boolean | null;

export type UserUpdateIsVerified = boolean | null;

/**
 * 更新.
 */
export interface UserUpdate {
  password?: UserUpdatePassword;
  email?: UserUpdateEmail;
  is_active?: UserUpdateIsActive;
  is_superuser?: UserUpdateIsSuperuser;
  is_verified?: UserUpdateIsVerified;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * 参照用の無意味な記号(参照を持たない)
 */
export type KnowdePrimitiveTermTermAlias = string | null;

/**
 * 用語.
 */
export interface KnowdePrimitiveTermTerm {
  names?: string[];
  /** 参照用の無意味な記号(参照を持たない) */
  alias?: KnowdePrimitiveTermTermAlias;
}

export type KnowdeTmpDefinitionTermDomainTermUid = string | null;

export interface KnowdeTmpDefinitionTermDomainTerm {
  uid?: KnowdeTmpDefinitionTermDomainTermUid;
  created: string;
  updated: string;
  /**
   * 用語名
   * @maxLength 32
   */
  value: string;
}

export type CompleteDefinitionDefinitionCompletionGetParams = {
  pref_uid: string;
};

export type CompletePropositionPropositionCompletionGetParams = {
  pref_uid: string;
};

export type CompleteDeductionMapperDeductionCompletionGetParams = {
  pref_uid: string;
};

export type OauthGoogleJwtAuthorizeGoogleAuthorizeGetParams = {
  scopes?: string[];
};

export type OauthGoogleJwtCallbackGoogleCallbackGetParams = {
  code?: string | null;
  code_verifier?: string | null;
  state?: string | null;
  error?: string | null;
};

export type SearchByTextKnowdeGetParams = {
  q?: string;
  type?: SearchByTextKnowdeGetType;
  paging?: Paging;
  order?: OrderBy | null;
};

export type SearchByTextKnowdeGetType =
  (typeof SearchByTextKnowdeGetType)[keyof typeof SearchByTextKnowdeGetType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchByTextKnowdeGetType = {
  CONTAINS: "CONTAINS",
  STARTS_WITH: "STARTS_WITH",
  ENDS_WITH: "ENDS_WITH",
  REGEX: "REGEX",
  EQUAL: "EQUAL",
} as const;

/**
 * とりあえず一覧を返す.

本当は依存関係の統計値も返したいが、開発が進んでから再検討しよう
 * @summary List Definitions
 */
export type listDefinitionsDefinitionGetResponse200 = {
  data: StatsDefinitions;
  status: 200;
};

export type listDefinitionsDefinitionGetResponseComposite =
  listDefinitionsDefinitionGetResponse200;

export type listDefinitionsDefinitionGetResponse =
  listDefinitionsDefinitionGetResponseComposite & {
    headers: Headers;
  };

export const getListDefinitionsDefinitionGetUrl = () => {
  return "http://localhost:8000/definition";
};

export const listDefinitionsDefinitionGet = async (
  options?: RequestInit,
): Promise<listDefinitionsDefinitionGetResponse> => {
  const res = await fetch(getListDefinitionsDefinitionGetUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: listDefinitionsDefinitionGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as listDefinitionsDefinitionGetResponse;
};

/**
 * @summary Add Definition
 */
export type addDefinitionDefinitionPostResponse201 = {
  data: Definition;
  status: 201;
};

export type addDefinitionDefinitionPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type addDefinitionDefinitionPostResponseComposite =
  | addDefinitionDefinitionPostResponse201
  | addDefinitionDefinitionPostResponse422;

export type addDefinitionDefinitionPostResponse =
  addDefinitionDefinitionPostResponseComposite & {
    headers: Headers;
  };

export const getAddDefinitionDefinitionPostUrl = () => {
  return "http://localhost:8000/definition";
};

export const addDefinitionDefinitionPost = async (
  definitionParam: DefinitionParam,
  options?: RequestInit,
): Promise<addDefinitionDefinitionPostResponse> => {
  const res = await fetch(getAddDefinitionDefinitionPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(definitionParam),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: addDefinitionDefinitionPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as addDefinitionDefinitionPostResponse;
};

/**
 * 前方一致検索.
 * @summary Complete Definition
 */
export type completeDefinitionDefinitionCompletionGetResponse200 = {
  data: Definition;
  status: 200;
};

export type completeDefinitionDefinitionCompletionGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type completeDefinitionDefinitionCompletionGetResponseComposite =
  | completeDefinitionDefinitionCompletionGetResponse200
  | completeDefinitionDefinitionCompletionGetResponse422;

export type completeDefinitionDefinitionCompletionGetResponse =
  completeDefinitionDefinitionCompletionGetResponseComposite & {
    headers: Headers;
  };

export const getCompleteDefinitionDefinitionCompletionGetUrl = (
  params: CompleteDefinitionDefinitionCompletionGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8000/definition/completion?${stringifiedParams}`
    : "http://localhost:8000/definition/completion";
};

export const completeDefinitionDefinitionCompletionGet = async (
  params: CompleteDefinitionDefinitionCompletionGetParams,
  options?: RequestInit,
): Promise<completeDefinitionDefinitionCompletionGetResponse> => {
  const res = await fetch(
    getCompleteDefinitionDefinitionCompletionGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: completeDefinitionDefinitionCompletionGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as completeDefinitionDefinitionCompletionGetResponse;
};

/**
 * 定義の詳細.
 * @summary Detail Service
 */
export type detailServiceDefinitionDefUidGetResponse200 = {
  data: DetailView;
  status: 200;
};

export type detailServiceDefinitionDefUidGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type detailServiceDefinitionDefUidGetResponseComposite =
  | detailServiceDefinitionDefUidGetResponse200
  | detailServiceDefinitionDefUidGetResponse422;

export type detailServiceDefinitionDefUidGetResponse =
  detailServiceDefinitionDefUidGetResponseComposite & {
    headers: Headers;
  };

export const getDetailServiceDefinitionDefUidGetUrl = (defUid: string) => {
  return `http://localhost:8000/definition/${defUid}`;
};

export const detailServiceDefinitionDefUidGet = async (
  defUid: string,
  options?: RequestInit,
): Promise<detailServiceDefinitionDefUidGetResponse> => {
  const res = await fetch(getDetailServiceDefinitionDefUidGetUrl(defUid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: detailServiceDefinitionDefUidGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as detailServiceDefinitionDefUidGetResponse;
};

/**
 * 定義の削除.
 * @summary Remove Definition
 */
export type removeDefinitionDefinitionDefUidDeleteResponse204 = {
  data: undefined;
  status: 204;
};

export type removeDefinitionDefinitionDefUidDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type removeDefinitionDefinitionDefUidDeleteResponseComposite =
  | removeDefinitionDefinitionDefUidDeleteResponse204
  | removeDefinitionDefinitionDefUidDeleteResponse422;

export type removeDefinitionDefinitionDefUidDeleteResponse =
  removeDefinitionDefinitionDefUidDeleteResponseComposite & {
    headers: Headers;
  };

export const getRemoveDefinitionDefinitionDefUidDeleteUrl = (
  defUid: string,
) => {
  return `http://localhost:8000/definition/${defUid}`;
};

export const removeDefinitionDefinitionDefUidDelete = async (
  defUid: string,
  options?: RequestInit,
): Promise<removeDefinitionDefinitionDefUidDeleteResponse> => {
  const res = await fetch(
    getRemoveDefinitionDefinitionDefUidDeleteUrl(defUid),
    {
      ...options,
      method: "DELETE",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: removeDefinitionDefinitionDefUidDeleteResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as removeDefinitionDefinitionDefUidDeleteResponse;
};

/**
 * 命題一覧.
 * @summary List Propositions
 */
export type listPropositionsPropositionGetResponse200 = {
  data: Proposition[];
  status: 200;
};

export type listPropositionsPropositionGetResponseComposite =
  listPropositionsPropositionGetResponse200;

export type listPropositionsPropositionGetResponse =
  listPropositionsPropositionGetResponseComposite & {
    headers: Headers;
  };

export const getListPropositionsPropositionGetUrl = () => {
  return "http://localhost:8000/proposition";
};

export const listPropositionsPropositionGet = async (
  options?: RequestInit,
): Promise<listPropositionsPropositionGetResponse> => {
  const res = await fetch(getListPropositionsPropositionGetUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: listPropositionsPropositionGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as listPropositionsPropositionGetResponse;
};

/**
 * @summary Add Proposition
 */
export type addPropositionPropositionPostResponse201 = {
  data: unknown;
  status: 201;
};

export type addPropositionPropositionPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type addPropositionPropositionPostResponseComposite =
  | addPropositionPropositionPostResponse201
  | addPropositionPropositionPostResponse422;

export type addPropositionPropositionPostResponse =
  addPropositionPropositionPostResponseComposite & {
    headers: Headers;
  };

export const getAddPropositionPropositionPostUrl = () => {
  return "http://localhost:8000/proposition";
};

export const addPropositionPropositionPost = async (
  propositionParam: PropositionParam,
  options?: RequestInit,
): Promise<addPropositionPropositionPostResponse> => {
  const res = await fetch(getAddPropositionPropositionPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(propositionParam),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: addPropositionPropositionPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as addPropositionPropositionPostResponse;
};

/**
 * 補完.
 * @summary Complete Proposition
 */
export type completePropositionPropositionCompletionGetResponse200 = {
  data: Proposition;
  status: 200;
};

export type completePropositionPropositionCompletionGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type completePropositionPropositionCompletionGetResponseComposite =
  | completePropositionPropositionCompletionGetResponse200
  | completePropositionPropositionCompletionGetResponse422;

export type completePropositionPropositionCompletionGetResponse =
  completePropositionPropositionCompletionGetResponseComposite & {
    headers: Headers;
  };

export const getCompletePropositionPropositionCompletionGetUrl = (
  params: CompletePropositionPropositionCompletionGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8000/proposition/completion?${stringifiedParams}`
    : "http://localhost:8000/proposition/completion";
};

export const completePropositionPropositionCompletionGet = async (
  params: CompletePropositionPropositionCompletionGetParams,
  options?: RequestInit,
): Promise<completePropositionPropositionCompletionGetResponse> => {
  const res = await fetch(
    getCompletePropositionPropositionCompletionGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: completePropositionPropositionCompletionGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as completePropositionPropositionCompletionGetResponse;
};

/**
 * @summary Change Proposition
 */
export type changePropositionPropositionUidPutResponse200 = {
  data: unknown;
  status: 200;
};

export type changePropositionPropositionUidPutResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type changePropositionPropositionUidPutResponseComposite =
  | changePropositionPropositionUidPutResponse200
  | changePropositionPropositionUidPutResponse422;

export type changePropositionPropositionUidPutResponse =
  changePropositionPropositionUidPutResponseComposite & {
    headers: Headers;
  };

export const getChangePropositionPropositionUidPutUrl = (uid: string) => {
  return `http://localhost:8000/proposition/${uid}`;
};

export const changePropositionPropositionUidPut = async (
  uid: string,
  propositionParam: PropositionParam,
  options?: RequestInit,
): Promise<changePropositionPropositionUidPutResponse> => {
  const res = await fetch(getChangePropositionPropositionUidPutUrl(uid), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(propositionParam),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: changePropositionPropositionUidPutResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as changePropositionPropositionUidPutResponse;
};

/**
 * 命題の削除.
 * @summary Delete Proposition
 */
export type deletePropositionPropositionUidDeleteResponse204 = {
  data: undefined;
  status: 204;
};

export type deletePropositionPropositionUidDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deletePropositionPropositionUidDeleteResponseComposite =
  | deletePropositionPropositionUidDeleteResponse204
  | deletePropositionPropositionUidDeleteResponse422;

export type deletePropositionPropositionUidDeleteResponse =
  deletePropositionPropositionUidDeleteResponseComposite & {
    headers: Headers;
  };

export const getDeletePropositionPropositionUidDeleteUrl = (uid: string) => {
  return `http://localhost:8000/proposition/${uid}`;
};

export const deletePropositionPropositionUidDelete = async (
  uid: string,
  options?: RequestInit,
): Promise<deletePropositionPropositionUidDeleteResponse> => {
  const res = await fetch(getDeletePropositionPropositionUidDeleteUrl(uid), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: deletePropositionPropositionUidDeleteResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as deletePropositionPropositionUidDeleteResponse;
};

/**
 * 演繹一覧.
 * @summary List Deductions
 */
export type listDeductionsDeductionGetResponse200 = {
  data: StatsDeductions;
  status: 200;
};

export type listDeductionsDeductionGetResponseComposite =
  listDeductionsDeductionGetResponse200;

export type listDeductionsDeductionGetResponse =
  listDeductionsDeductionGetResponseComposite & {
    headers: Headers;
  };

export const getListDeductionsDeductionGetUrl = () => {
  return "http://localhost:8000/deduction";
};

export const listDeductionsDeductionGet = async (
  options?: RequestInit,
): Promise<listDeductionsDeductionGetResponse> => {
  const res = await fetch(getListDeductionsDeductionGetUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: listDeductionsDeductionGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as listDeductionsDeductionGetResponse;
};

/**
 * @summary Deduct
 */
export type deductDeductionPostResponse201 = {
  data: Deduction;
  status: 201;
};

export type deductDeductionPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deductDeductionPostResponseComposite =
  | deductDeductionPostResponse201
  | deductDeductionPostResponse422;

export type deductDeductionPostResponse =
  deductDeductionPostResponseComposite & {
    headers: Headers;
  };

export const getDeductDeductionPostUrl = () => {
  return "http://localhost:8000/deduction";
};

export const deductDeductionPost = async (
  deductionParam: DeductionParam,
  options?: RequestInit,
): Promise<deductDeductionPostResponse> => {
  const res = await fetch(getDeductDeductionPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(deductionParam),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: deductDeductionPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as deductDeductionPostResponse;
};

/**
 * 補完.
 * @summary Complete Deduction Mapper
 */
export type completeDeductionMapperDeductionCompletionGetResponse200 = {
  data: DeductionMapper;
  status: 200;
};

export type completeDeductionMapperDeductionCompletionGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type completeDeductionMapperDeductionCompletionGetResponseComposite =
  | completeDeductionMapperDeductionCompletionGetResponse200
  | completeDeductionMapperDeductionCompletionGetResponse422;

export type completeDeductionMapperDeductionCompletionGetResponse =
  completeDeductionMapperDeductionCompletionGetResponseComposite & {
    headers: Headers;
  };

export const getCompleteDeductionMapperDeductionCompletionGetUrl = (
  params: CompleteDeductionMapperDeductionCompletionGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8000/deduction/completion?${stringifiedParams}`
    : "http://localhost:8000/deduction/completion";
};

export const completeDeductionMapperDeductionCompletionGet = async (
  params: CompleteDeductionMapperDeductionCompletionGetParams,
  options?: RequestInit,
): Promise<completeDeductionMapperDeductionCompletionGetResponse> => {
  const res = await fetch(
    getCompleteDeductionMapperDeductionCompletionGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: completeDeductionMapperDeductionCompletionGetResponse["data"] =
    body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as completeDeductionMapperDeductionCompletionGetResponse;
};

/**
 * 演繹の削除.
 * @summary Remove Deduction
 */
export type removeDeductionDeductionUidDeleteResponse204 = {
  data: undefined;
  status: 204;
};

export type removeDeductionDeductionUidDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type removeDeductionDeductionUidDeleteResponseComposite =
  | removeDeductionDeductionUidDeleteResponse204
  | removeDeductionDeductionUidDeleteResponse422;

export type removeDeductionDeductionUidDeleteResponse =
  removeDeductionDeductionUidDeleteResponseComposite & {
    headers: Headers;
  };

export const getRemoveDeductionDeductionUidDeleteUrl = (uid: string) => {
  return `http://localhost:8000/deduction/${uid}`;
};

export const removeDeductionDeductionUidDelete = async (
  uid: string,
  options?: RequestInit,
): Promise<removeDeductionDeductionUidDeleteResponse> => {
  const res = await fetch(getRemoveDeductionDeductionUidDeleteUrl(uid), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: removeDeductionDeductionUidDeleteResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as removeDeductionDeductionUidDeleteResponse;
};

/**
 * @summary Replace Premises
 */
export type replacePremisesDeductionUidPremisesPutResponse200 = {
  data: Deduction;
  status: 200;
};

export type replacePremisesDeductionUidPremisesPutResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type replacePremisesDeductionUidPremisesPutResponseComposite =
  | replacePremisesDeductionUidPremisesPutResponse200
  | replacePremisesDeductionUidPremisesPutResponse422;

export type replacePremisesDeductionUidPremisesPutResponse =
  replacePremisesDeductionUidPremisesPutResponseComposite & {
    headers: Headers;
  };

export const getReplacePremisesDeductionUidPremisesPutUrl = (uid: string) => {
  return `http://localhost:8000/deduction/${uid}/premises`;
};

export const replacePremisesDeductionUidPremisesPut = async (
  uid: string,
  replacePremisesAPIParam: ReplacePremisesAPIParam,
  options?: RequestInit,
): Promise<replacePremisesDeductionUidPremisesPutResponse> => {
  const res = await fetch(getReplacePremisesDeductionUidPremisesPutUrl(uid), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(replacePremisesAPIParam),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: replacePremisesDeductionUidPremisesPutResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as replacePremisesDeductionUidPremisesPutResponse;
};

/**
 * @summary Replace Conclusion
 */
export type replaceConclusionDeductionUidConclusionPutResponse200 = {
  data: Deduction;
  status: 200;
};

export type replaceConclusionDeductionUidConclusionPutResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type replaceConclusionDeductionUidConclusionPutResponseComposite =
  | replaceConclusionDeductionUidConclusionPutResponse200
  | replaceConclusionDeductionUidConclusionPutResponse422;

export type replaceConclusionDeductionUidConclusionPutResponse =
  replaceConclusionDeductionUidConclusionPutResponseComposite & {
    headers: Headers;
  };

export const getReplaceConclusionDeductionUidConclusionPutUrl = (
  uid: string,
) => {
  return `http://localhost:8000/deduction/${uid}/conclusion`;
};

export const replaceConclusionDeductionUidConclusionPut = async (
  uid: string,
  replaceConclusionAPIParam: ReplaceConclusionAPIParam,
  options?: RequestInit,
): Promise<replaceConclusionDeductionUidConclusionPutResponse> => {
  const res = await fetch(
    getReplaceConclusionDeductionUidConclusionPutUrl(uid),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(replaceConclusionAPIParam),
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: replaceConclusionDeductionUidConclusionPutResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as replaceConclusionDeductionUidConclusionPutResponse;
};

/**
 * @summary Auth:Jwt.Login
 */
export type authJwtLoginAuthJwtLoginPostResponse200 = {
  data: BearerResponse;
  status: 200;
};

export type authJwtLoginAuthJwtLoginPostResponse400 = {
  data: ErrorModel;
  status: 400;
};

export type authJwtLoginAuthJwtLoginPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type authJwtLoginAuthJwtLoginPostResponseComposite =
  | authJwtLoginAuthJwtLoginPostResponse200
  | authJwtLoginAuthJwtLoginPostResponse400
  | authJwtLoginAuthJwtLoginPostResponse422;

export type authJwtLoginAuthJwtLoginPostResponse =
  authJwtLoginAuthJwtLoginPostResponseComposite & {
    headers: Headers;
  };

export const getAuthJwtLoginAuthJwtLoginPostUrl = () => {
  return "http://localhost:8000/auth/jwt/login";
};

export const authJwtLoginAuthJwtLoginPost = async (
  bodyAuthJwtLoginAuthJwtLoginPost: BodyAuthJwtLoginAuthJwtLoginPost,
  options?: RequestInit,
): Promise<authJwtLoginAuthJwtLoginPostResponse> => {
  const formUrlEncoded = new URLSearchParams();
  if (
    bodyAuthJwtLoginAuthJwtLoginPost.grant_type !== undefined &&
    bodyAuthJwtLoginAuthJwtLoginPost.grant_type !== null
  ) {
    formUrlEncoded.append(
      "grant_type",
      bodyAuthJwtLoginAuthJwtLoginPost.grant_type,
    );
  }
  formUrlEncoded.append("username", bodyAuthJwtLoginAuthJwtLoginPost.username);
  formUrlEncoded.append("password", bodyAuthJwtLoginAuthJwtLoginPost.password);
  if (bodyAuthJwtLoginAuthJwtLoginPost.scope !== undefined) {
    formUrlEncoded.append("scope", bodyAuthJwtLoginAuthJwtLoginPost.scope);
  }
  if (
    bodyAuthJwtLoginAuthJwtLoginPost.client_id !== undefined &&
    bodyAuthJwtLoginAuthJwtLoginPost.client_id !== null
  ) {
    formUrlEncoded.append(
      "client_id",
      bodyAuthJwtLoginAuthJwtLoginPost.client_id,
    );
  }
  if (
    bodyAuthJwtLoginAuthJwtLoginPost.client_secret !== undefined &&
    bodyAuthJwtLoginAuthJwtLoginPost.client_secret !== null
  ) {
    formUrlEncoded.append(
      "client_secret",
      bodyAuthJwtLoginAuthJwtLoginPost.client_secret,
    );
  }

  const res = await fetch(getAuthJwtLoginAuthJwtLoginPostUrl(), {
    ...options,
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      ...options?.headers,
    },
    body: formUrlEncoded,
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: authJwtLoginAuthJwtLoginPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as authJwtLoginAuthJwtLoginPostResponse;
};

/**
 * @summary Auth:Jwt.Logout
 */
export type authJwtLogoutAuthJwtLogoutPostResponse200 = {
  data: unknown;
  status: 200;
};

export type authJwtLogoutAuthJwtLogoutPostResponse401 = {
  data: undefined;
  status: 401;
};

export type authJwtLogoutAuthJwtLogoutPostResponseComposite =
  | authJwtLogoutAuthJwtLogoutPostResponse200
  | authJwtLogoutAuthJwtLogoutPostResponse401;

export type authJwtLogoutAuthJwtLogoutPostResponse =
  authJwtLogoutAuthJwtLogoutPostResponseComposite & {
    headers: Headers;
  };

export const getAuthJwtLogoutAuthJwtLogoutPostUrl = () => {
  return "http://localhost:8000/auth/jwt/logout";
};

export const authJwtLogoutAuthJwtLogoutPost = async (
  options?: RequestInit,
): Promise<authJwtLogoutAuthJwtLogoutPostResponse> => {
  const res = await fetch(getAuthJwtLogoutAuthJwtLogoutPostUrl(), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: authJwtLogoutAuthJwtLogoutPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as authJwtLogoutAuthJwtLogoutPostResponse;
};

/**
 * @summary Register:Register
 */
export type registerRegisterAuthRegisterPostResponse201 = {
  data: UserRead;
  status: 201;
};

export type registerRegisterAuthRegisterPostResponse400 = {
  data: ErrorModel;
  status: 400;
};

export type registerRegisterAuthRegisterPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type registerRegisterAuthRegisterPostResponseComposite =
  | registerRegisterAuthRegisterPostResponse201
  | registerRegisterAuthRegisterPostResponse400
  | registerRegisterAuthRegisterPostResponse422;

export type registerRegisterAuthRegisterPostResponse =
  registerRegisterAuthRegisterPostResponseComposite & {
    headers: Headers;
  };

export const getRegisterRegisterAuthRegisterPostUrl = () => {
  return "http://localhost:8000/auth/register";
};

export const registerRegisterAuthRegisterPost = async (
  userCreate: UserCreate,
  options?: RequestInit,
): Promise<registerRegisterAuthRegisterPostResponse> => {
  const res = await fetch(getRegisterRegisterAuthRegisterPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userCreate),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: registerRegisterAuthRegisterPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as registerRegisterAuthRegisterPostResponse;
};

/**
 * @summary Reset:Forgot Password
 */
export type resetForgotPasswordAuthForgotPasswordPostResponse202 = {
  data: unknown;
  status: 202;
};

export type resetForgotPasswordAuthForgotPasswordPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type resetForgotPasswordAuthForgotPasswordPostResponseComposite =
  | resetForgotPasswordAuthForgotPasswordPostResponse202
  | resetForgotPasswordAuthForgotPasswordPostResponse422;

export type resetForgotPasswordAuthForgotPasswordPostResponse =
  resetForgotPasswordAuthForgotPasswordPostResponseComposite & {
    headers: Headers;
  };

export const getResetForgotPasswordAuthForgotPasswordPostUrl = () => {
  return "http://localhost:8000/auth/forgot-password";
};

export const resetForgotPasswordAuthForgotPasswordPost = async (
  bodyResetForgotPasswordAuthForgotPasswordPost: BodyResetForgotPasswordAuthForgotPasswordPost,
  options?: RequestInit,
): Promise<resetForgotPasswordAuthForgotPasswordPostResponse> => {
  const res = await fetch(getResetForgotPasswordAuthForgotPasswordPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(bodyResetForgotPasswordAuthForgotPasswordPost),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: resetForgotPasswordAuthForgotPasswordPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as resetForgotPasswordAuthForgotPasswordPostResponse;
};

/**
 * @summary Reset:Reset Password
 */
export type resetResetPasswordAuthResetPasswordPostResponse200 = {
  data: unknown;
  status: 200;
};

export type resetResetPasswordAuthResetPasswordPostResponse400 = {
  data: ErrorModel;
  status: 400;
};

export type resetResetPasswordAuthResetPasswordPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type resetResetPasswordAuthResetPasswordPostResponseComposite =
  | resetResetPasswordAuthResetPasswordPostResponse200
  | resetResetPasswordAuthResetPasswordPostResponse400
  | resetResetPasswordAuthResetPasswordPostResponse422;

export type resetResetPasswordAuthResetPasswordPostResponse =
  resetResetPasswordAuthResetPasswordPostResponseComposite & {
    headers: Headers;
  };

export const getResetResetPasswordAuthResetPasswordPostUrl = () => {
  return "http://localhost:8000/auth/reset-password";
};

export const resetResetPasswordAuthResetPasswordPost = async (
  bodyResetResetPasswordAuthResetPasswordPost: BodyResetResetPasswordAuthResetPasswordPost,
  options?: RequestInit,
): Promise<resetResetPasswordAuthResetPasswordPostResponse> => {
  const res = await fetch(getResetResetPasswordAuthResetPasswordPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(bodyResetResetPasswordAuthResetPasswordPost),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: resetResetPasswordAuthResetPasswordPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as resetResetPasswordAuthResetPasswordPostResponse;
};

/**
 * @summary Verify:Request-Token
 */
export type verifyRequestTokenAuthRequestVerifyTokenPostResponse202 = {
  data: unknown;
  status: 202;
};

export type verifyRequestTokenAuthRequestVerifyTokenPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type verifyRequestTokenAuthRequestVerifyTokenPostResponseComposite =
  | verifyRequestTokenAuthRequestVerifyTokenPostResponse202
  | verifyRequestTokenAuthRequestVerifyTokenPostResponse422;

export type verifyRequestTokenAuthRequestVerifyTokenPostResponse =
  verifyRequestTokenAuthRequestVerifyTokenPostResponseComposite & {
    headers: Headers;
  };

export const getVerifyRequestTokenAuthRequestVerifyTokenPostUrl = () => {
  return "http://localhost:8000/auth/request-verify-token";
};

export const verifyRequestTokenAuthRequestVerifyTokenPost = async (
  bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
  options?: RequestInit,
): Promise<verifyRequestTokenAuthRequestVerifyTokenPostResponse> => {
  const res = await fetch(
    getVerifyRequestTokenAuthRequestVerifyTokenPostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(bodyVerifyRequestTokenAuthRequestVerifyTokenPost),
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: verifyRequestTokenAuthRequestVerifyTokenPostResponse["data"] =
    body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as verifyRequestTokenAuthRequestVerifyTokenPostResponse;
};

/**
 * @summary Verify:Verify
 */
export type verifyVerifyAuthVerifyPostResponse200 = {
  data: UserRead;
  status: 200;
};

export type verifyVerifyAuthVerifyPostResponse400 = {
  data: ErrorModel;
  status: 400;
};

export type verifyVerifyAuthVerifyPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type verifyVerifyAuthVerifyPostResponseComposite =
  | verifyVerifyAuthVerifyPostResponse200
  | verifyVerifyAuthVerifyPostResponse400
  | verifyVerifyAuthVerifyPostResponse422;

export type verifyVerifyAuthVerifyPostResponse =
  verifyVerifyAuthVerifyPostResponseComposite & {
    headers: Headers;
  };

export const getVerifyVerifyAuthVerifyPostUrl = () => {
  return "http://localhost:8000/auth/verify";
};

export const verifyVerifyAuthVerifyPost = async (
  bodyVerifyVerifyAuthVerifyPost: BodyVerifyVerifyAuthVerifyPost,
  options?: RequestInit,
): Promise<verifyVerifyAuthVerifyPostResponse> => {
  const res = await fetch(getVerifyVerifyAuthVerifyPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(bodyVerifyVerifyAuthVerifyPost),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: verifyVerifyAuthVerifyPostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as verifyVerifyAuthVerifyPostResponse;
};

/**
 * @summary Oauth:Google.Jwt.Authorize
 */
export type oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse200 = {
  data: OAuth2AuthorizeResponse;
  status: 200;
};

export type oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponseComposite =
  | oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse200
  | oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse422;

export type oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse =
  oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponseComposite & {
    headers: Headers;
  };

export const getOauthGoogleJwtAuthorizeGoogleAuthorizeGetUrl = (
  params?: OauthGoogleJwtAuthorizeGoogleAuthorizeGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8000/google/authorize?${stringifiedParams}`
    : "http://localhost:8000/google/authorize";
};

export const oauthGoogleJwtAuthorizeGoogleAuthorizeGet = async (
  params?: OauthGoogleJwtAuthorizeGoogleAuthorizeGetParams,
  options?: RequestInit,
): Promise<oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse> => {
  const res = await fetch(
    getOauthGoogleJwtAuthorizeGoogleAuthorizeGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as oauthGoogleJwtAuthorizeGoogleAuthorizeGetResponse;
};

/**
 * The response varies based on the authentication backend used.
 * @summary Oauth:Google.Jwt.Callback
 */
export type oauthGoogleJwtCallbackGoogleCallbackGetResponse200 = {
  data: unknown;
  status: 200;
};

export type oauthGoogleJwtCallbackGoogleCallbackGetResponse400 = {
  data: ErrorModel;
  status: 400;
};

export type oauthGoogleJwtCallbackGoogleCallbackGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type oauthGoogleJwtCallbackGoogleCallbackGetResponseComposite =
  | oauthGoogleJwtCallbackGoogleCallbackGetResponse200
  | oauthGoogleJwtCallbackGoogleCallbackGetResponse400
  | oauthGoogleJwtCallbackGoogleCallbackGetResponse422;

export type oauthGoogleJwtCallbackGoogleCallbackGetResponse =
  oauthGoogleJwtCallbackGoogleCallbackGetResponseComposite & {
    headers: Headers;
  };

export const getOauthGoogleJwtCallbackGoogleCallbackGetUrl = (
  params?: OauthGoogleJwtCallbackGoogleCallbackGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8000/google/callback?${stringifiedParams}`
    : "http://localhost:8000/google/callback";
};

export const oauthGoogleJwtCallbackGoogleCallbackGet = async (
  params?: OauthGoogleJwtCallbackGoogleCallbackGetParams,
  options?: RequestInit,
): Promise<oauthGoogleJwtCallbackGoogleCallbackGetResponse> => {
  const res = await fetch(
    getOauthGoogleJwtCallbackGoogleCallbackGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: oauthGoogleJwtCallbackGoogleCallbackGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as oauthGoogleJwtCallbackGoogleCallbackGetResponse;
};

/**
 * @summary Users:Current User
 */
export type usersCurrentUserUserMeGetResponse200 = {
  data: UserRead;
  status: 200;
};

export type usersCurrentUserUserMeGetResponse401 = {
  data: undefined;
  status: 401;
};

export type usersCurrentUserUserMeGetResponseComposite =
  | usersCurrentUserUserMeGetResponse200
  | usersCurrentUserUserMeGetResponse401;

export type usersCurrentUserUserMeGetResponse =
  usersCurrentUserUserMeGetResponseComposite & {
    headers: Headers;
  };

export const getUsersCurrentUserUserMeGetUrl = () => {
  return "http://localhost:8000/user/me";
};

export const usersCurrentUserUserMeGet = async (
  options?: RequestInit,
): Promise<usersCurrentUserUserMeGetResponse> => {
  const res = await fetch(getUsersCurrentUserUserMeGetUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: usersCurrentUserUserMeGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as usersCurrentUserUserMeGetResponse;
};

/**
 * @summary Users:Patch Current User
 */
export type usersPatchCurrentUserUserMePatchResponse200 = {
  data: UserRead;
  status: 200;
};

export type usersPatchCurrentUserUserMePatchResponse400 = {
  data: ErrorModel;
  status: 400;
};

export type usersPatchCurrentUserUserMePatchResponse401 = {
  data: undefined;
  status: 401;
};

export type usersPatchCurrentUserUserMePatchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type usersPatchCurrentUserUserMePatchResponseComposite =
  | usersPatchCurrentUserUserMePatchResponse200
  | usersPatchCurrentUserUserMePatchResponse400
  | usersPatchCurrentUserUserMePatchResponse401
  | usersPatchCurrentUserUserMePatchResponse422;

export type usersPatchCurrentUserUserMePatchResponse =
  usersPatchCurrentUserUserMePatchResponseComposite & {
    headers: Headers;
  };

export const getUsersPatchCurrentUserUserMePatchUrl = () => {
  return "http://localhost:8000/user/me";
};

export const usersPatchCurrentUserUserMePatch = async (
  userUpdate: UserUpdate,
  options?: RequestInit,
): Promise<usersPatchCurrentUserUserMePatchResponse> => {
  const res = await fetch(getUsersPatchCurrentUserUserMePatchUrl(), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userUpdate),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: usersPatchCurrentUserUserMePatchResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as usersPatchCurrentUserUserMePatchResponse;
};

/**
 * @summary Users:User
 */
export type usersUserUserIdGetResponse200 = {
  data: UserRead;
  status: 200;
};

export type usersUserUserIdGetResponse401 = {
  data: undefined;
  status: 401;
};

export type usersUserUserIdGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type usersUserUserIdGetResponseComposite =
  | usersUserUserIdGetResponse200
  | usersUserUserIdGetResponse401
  | usersUserUserIdGetResponse422;

export type usersUserUserIdGetResponse = usersUserUserIdGetResponseComposite & {
  headers: Headers;
};

export const getUsersUserUserIdGetUrl = (id: string) => {
  return `http://localhost:8000/user/${id}`;
};

export const usersUserUserIdGet = async (
  id: string,
  options?: RequestInit,
): Promise<usersUserUserIdGetResponse> => {
  const res = await fetch(getUsersUserUserIdGetUrl(id), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: usersUserUserIdGetResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as usersUserUserIdGetResponse;
};

/**
 * @summary Users:Patch User
 */
export type usersPatchUserUserIdPatchResponse200 = {
  data: UserRead;
  status: 200;
};

export type usersPatchUserUserIdPatchResponse400 = {
  data: ErrorModel;
  status: 400;
};

export type usersPatchUserUserIdPatchResponse401 = {
  data: undefined;
  status: 401;
};

export type usersPatchUserUserIdPatchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type usersPatchUserUserIdPatchResponseComposite =
  | usersPatchUserUserIdPatchResponse200
  | usersPatchUserUserIdPatchResponse400
  | usersPatchUserUserIdPatchResponse401
  | usersPatchUserUserIdPatchResponse422;

export type usersPatchUserUserIdPatchResponse =
  usersPatchUserUserIdPatchResponseComposite & {
    headers: Headers;
  };

export const getUsersPatchUserUserIdPatchUrl = (id: string) => {
  return `http://localhost:8000/user/${id}`;
};

export const usersPatchUserUserIdPatch = async (
  id: string,
  userUpdate: UserUpdate,
  options?: RequestInit,
): Promise<usersPatchUserUserIdPatchResponse> => {
  const res = await fetch(getUsersPatchUserUserIdPatchUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userUpdate),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: usersPatchUserUserIdPatchResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as usersPatchUserUserIdPatchResponse;
};

/**
 * @summary Users:Delete User
 */
export type usersDeleteUserUserIdDeleteResponse204 = {
  data: undefined;
  status: 204;
};

export type usersDeleteUserUserIdDeleteResponse401 = {
  data: undefined;
  status: 401;
};

export type usersDeleteUserUserIdDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type usersDeleteUserUserIdDeleteResponseComposite =
  | usersDeleteUserUserIdDeleteResponse204
  | usersDeleteUserUserIdDeleteResponse401
  | usersDeleteUserUserIdDeleteResponse422;

export type usersDeleteUserUserIdDeleteResponse =
  usersDeleteUserUserIdDeleteResponseComposite & {
    headers: Headers;
  };

export const getUsersDeleteUserUserIdDeleteUrl = (id: string) => {
  return `http://localhost:8000/user/${id}`;
};

export const usersDeleteUserUserIdDelete = async (
  id: string,
  options?: RequestInit,
): Promise<usersDeleteUserUserIdDeleteResponse> => {
  const res = await fetch(getUsersDeleteUserUserIdDeleteUrl(id), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: usersDeleteUserUserIdDeleteResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as usersDeleteUserUserIdDeleteResponse;
};

/**
 * ユーザーの名前空間.
 * @summary Get Namaspace
 */
export type getNamaspaceNamespaceGetResponse200 = {
  data: NameSpace;
  status: 200;
};

export type getNamaspaceNamespaceGetResponseComposite =
  getNamaspaceNamespaceGetResponse200;

export type getNamaspaceNamespaceGetResponse =
  getNamaspaceNamespaceGetResponseComposite & {
    headers: Headers;
  };

export const getGetNamaspaceNamespaceGetUrl = () => {
  return "http://localhost:8000/namespace";
};

export const getNamaspaceNamespaceGet = async (
  options?: RequestInit,
): Promise<getNamaspaceNamespaceGetResponse> => {
  const res = await fetch(getGetNamaspaceNamespaceGetUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getNamaspaceNamespaceGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getNamaspaceNamespaceGetResponse;
};

/**
 * ファイルシステムと同期.
 * @summary Sync Paths
 */
export type syncPathsNamespacePostResponse200 = {
  data: string[];
  status: 200;
};

export type syncPathsNamespacePostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type syncPathsNamespacePostResponseComposite =
  | syncPathsNamespacePostResponse200
  | syncPathsNamespacePostResponse422;

export type syncPathsNamespacePostResponse =
  syncPathsNamespacePostResponseComposite & {
    headers: Headers;
  };

export const getSyncPathsNamespacePostUrl = () => {
  return "http://localhost:8000/namespace";
};

export const syncPathsNamespacePost = async (
  resourceMetas: ResourceMetas,
  options?: RequestInit,
): Promise<syncPathsNamespacePostResponse> => {
  const res = await fetch(getSyncPathsNamespacePostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(resourceMetas),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: syncPathsNamespacePostResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as syncPathsNamespacePostResponse;
};

/**
 * ファイルからsysnetを読み取って永続化.
 * @summary Read File
 */
export type readFileUploadPostResponse200 = {
  data: null;
  status: 200;
};

export type readFileUploadPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type readFileUploadPostResponseComposite =
  | readFileUploadPostResponse200
  | readFileUploadPostResponse422;

export type readFileUploadPostResponse = readFileUploadPostResponseComposite & {
  headers: Headers;
};

export const getReadFileUploadPostUrl = () => {
  return "http://localhost:8000/upload";
};

export const readFileUploadPost = async (
  bodyReadFileUploadPost: BodyReadFileUploadPost,
  options?: RequestInit,
): Promise<readFileUploadPostResponse> => {
  const formData = new FormData();
  bodyReadFileUploadPost.files.forEach((value) =>
    formData.append("files", value),
  );

  const res = await fetch(getReadFileUploadPostUrl(), {
    ...options,
    method: "POST",
    body: formData,
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: readFileUploadPostResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as readFileUploadPostResponse;
};

/**
 * 文字列検索.
 * @summary Search By Text
 */
export type searchByTextKnowdeGetResponse200 = {
  data: KAdjacency[];
  status: 200;
};

export type searchByTextKnowdeGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type searchByTextKnowdeGetResponseComposite =
  | searchByTextKnowdeGetResponse200
  | searchByTextKnowdeGetResponse422;

export type searchByTextKnowdeGetResponse =
  searchByTextKnowdeGetResponseComposite & {
    headers: Headers;
  };

export const getSearchByTextKnowdeGetUrl = (
  params?: SearchByTextKnowdeGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8000/knowde/?${stringifiedParams}`
    : "http://localhost:8000/knowde/";
};

export const searchByTextKnowdeGet = async (
  params?: SearchByTextKnowdeGetParams,
  options?: RequestInit,
): Promise<searchByTextKnowdeGetResponse> => {
  const res = await fetch(getSearchByTextKnowdeGetUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: searchByTextKnowdeGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as searchByTextKnowdeGetResponse;
};

/**
 * Check health.
 * @summary Check Health
 */
export type checkHealthHealthGetResponse200 = {
  data: string;
  status: 200;
};

export type checkHealthHealthGetResponseComposite =
  checkHealthHealthGetResponse200;

export type checkHealthHealthGetResponse =
  checkHealthHealthGetResponseComposite & {
    headers: Headers;
  };

export const getCheckHealthHealthGetUrl = () => {
  return "http://localhost:8000/health";
};

export const checkHealthHealthGet = async (
  options?: RequestInit,
): Promise<checkHealthHealthGetResponse> => {
  const res = await fetch(getCheckHealthHealthGetUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: checkHealthHealthGetResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as checkHealthHealthGetResponse;
};

export const getListDefinitionsDefinitionGetResponseMock = (
  overrideResponse: Partial<StatsDefinitions> = {},
): StatsDefinitions => ({
  values: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      definition: {
        uid: faker.helpers.arrayElement([
          faker.helpers.arrayElement([faker.string.uuid(), null]),
          undefined,
        ]),
        created: `${faker.date.past().toISOString().split(".")[0]}Z`,
        updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
        term: {
          uid: faker.helpers.arrayElement([
            faker.helpers.arrayElement([faker.string.uuid(), null]),
            undefined,
          ]),
          created: `${faker.date.past().toISOString().split(".")[0]}Z`,
          updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
          value: faker.string.alpha(20),
        },
        sentence: {
          uid: faker.helpers.arrayElement([
            faker.helpers.arrayElement([faker.string.uuid(), null]),
            undefined,
          ]),
          created: `${faker.date.past().toISOString().split(".")[0]}Z`,
          updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
          value: faker.string.alpha(20),
        },
        deps: faker.helpers.arrayElement([
          Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => ({
            uid: faker.helpers.arrayElement([
              faker.helpers.arrayElement([faker.string.uuid(), null]),
              undefined,
            ]),
            created: `${faker.date.past().toISOString().split(".")[0]}Z`,
            updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
            value: faker.string.alpha(20),
          })),
          undefined,
        ]),
      },
      statistics: {
        n_src: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        n_dest: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        max_root_dist: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        max_leaf_dist: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
      },
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getAddDefinitionDefinitionPostResponseMock = (
  overrideResponse: Partial<Definition> = {},
): Definition => ({
  uid: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  created: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
  term: {
    uid: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.uuid(), null]),
      undefined,
    ]),
    created: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
    value: faker.string.alpha(20),
  },
  sentence: {
    uid: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.uuid(), null]),
      undefined,
    ]),
    created: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
    value: faker.string.alpha(20),
  },
  deps: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      uid: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      created: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
      value: faker.string.alpha(20),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getCompleteDefinitionDefinitionCompletionGetResponseMock = (
  overrideResponse: Partial<Definition> = {},
): Definition => ({
  uid: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  created: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
  term: {
    uid: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.uuid(), null]),
      undefined,
    ]),
    created: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
    value: faker.string.alpha(20),
  },
  sentence: {
    uid: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.uuid(), null]),
      undefined,
    ]),
    created: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
    value: faker.string.alpha(20),
  },
  deps: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      uid: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      created: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
      value: faker.string.alpha(20),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getDetailServiceDefinitionDefUidGetResponseMock = (
  overrideResponse: Partial<DetailView> = {},
): DetailView => ({
  detail: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      {
        parent: {
          uid: faker.helpers.arrayElement([
            faker.helpers.arrayElement([faker.string.uuid(), null]),
            undefined,
          ]),
          created: `${faker.date.past().toISOString().split(".")[0]}Z`,
          updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
          term: {
            uid: faker.helpers.arrayElement([
              faker.helpers.arrayElement([faker.string.uuid(), null]),
              undefined,
            ]),
            created: `${faker.date.past().toISOString().split(".")[0]}Z`,
            updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
            value: faker.string.alpha(20),
          },
          sentence: {
            uid: faker.helpers.arrayElement([
              faker.helpers.arrayElement([faker.string.uuid(), null]),
              undefined,
            ]),
            created: `${faker.date.past().toISOString().split(".")[0]}Z`,
            updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
            value: faker.string.alpha(20),
          },
          deps: faker.helpers.arrayElement([
            Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              uid: faker.helpers.arrayElement([
                faker.helpers.arrayElement([faker.string.uuid(), null]),
                undefined,
              ]),
              created: `${faker.date.past().toISOString().split(".")[0]}Z`,
              updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
              value: faker.string.alpha(20),
            })),
            undefined,
          ]),
        },
        children: faker.helpers.arrayElement([[], undefined]),
      },
      null,
    ]),
    undefined,
  ]),
  ...overrideResponse,
});

export const getListPropositionsPropositionGetResponseMock =
  (): Proposition[] =>
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      uid: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      created: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
      text: faker.string.alpha(20),
    }));

export const getCompletePropositionPropositionCompletionGetResponseMock = (
  overrideResponse: Partial<Proposition> = {},
): Proposition => ({
  uid: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  created: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
  text: faker.string.alpha(20),
  ...overrideResponse,
});

export const getListDeductionsDeductionGetResponseMock = (
  overrideResponse: Partial<StatsDeductions> = {},
): StatsDeductions => ({
  values: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      deduction: {
        uid: faker.helpers.arrayElement([
          faker.helpers.arrayElement([faker.string.uuid(), null]),
          undefined,
        ]),
        created: `${faker.date.past().toISOString().split(".")[0]}Z`,
        updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
        text: faker.string.alpha(20),
        premises: faker.helpers.arrayElement([
          Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => ({
            uid: faker.helpers.arrayElement([
              faker.helpers.arrayElement([faker.string.uuid(), null]),
              undefined,
            ]),
            created: `${faker.date.past().toISOString().split(".")[0]}Z`,
            updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
            text: faker.string.alpha(20),
          })),
          undefined,
        ]),
        conclusion: {
          uid: faker.helpers.arrayElement([
            faker.helpers.arrayElement([faker.string.uuid(), null]),
            undefined,
          ]),
          created: `${faker.date.past().toISOString().split(".")[0]}Z`,
          updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
          text: faker.string.alpha(20),
        },
        valid: faker.datatype.boolean(),
      },
      stats: {
        n_src: faker.number.int({ min: undefined, max: undefined }),
        n_dest: faker.number.int({ min: undefined, max: undefined }),
        n_axiom: faker.number.int({ min: undefined, max: undefined }),
        n_leaf: faker.number.int({ min: undefined, max: undefined }),
        max_axiom_dist: faker.number.int({ min: undefined, max: undefined }),
        max_leaf_dist: faker.number.int({ min: undefined, max: undefined }),
      },
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getDeductDeductionPostResponseMock = (
  overrideResponse: Partial<Deduction> = {},
): Deduction => ({
  uid: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  created: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
  text: faker.string.alpha(20),
  premises: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      uid: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      created: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
      text: faker.string.alpha(20),
    })),
    undefined,
  ]),
  conclusion: {
    uid: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.uuid(), null]),
      undefined,
    ]),
    created: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
    text: faker.string.alpha(20),
  },
  valid: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getCompleteDeductionMapperDeductionCompletionGetResponseMock = (
  overrideResponse: Partial<DeductionMapper> = {},
): DeductionMapper => ({
  uid: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  created: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
  valid: faker.datatype.boolean(),
  text: faker.string.alpha(20),
  ...overrideResponse,
});

export const getReplacePremisesDeductionUidPremisesPutResponseMock = (
  overrideResponse: Partial<Deduction> = {},
): Deduction => ({
  uid: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  created: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
  text: faker.string.alpha(20),
  premises: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      uid: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      created: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
      text: faker.string.alpha(20),
    })),
    undefined,
  ]),
  conclusion: {
    uid: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.uuid(), null]),
      undefined,
    ]),
    created: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
    text: faker.string.alpha(20),
  },
  valid: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getReplaceConclusionDeductionUidConclusionPutResponseMock = (
  overrideResponse: Partial<Deduction> = {},
): Deduction => ({
  uid: faker.helpers.arrayElement([
    faker.helpers.arrayElement([faker.string.uuid(), null]),
    undefined,
  ]),
  created: `${faker.date.past().toISOString().split(".")[0]}Z`,
  updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
  text: faker.string.alpha(20),
  premises: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      uid: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.uuid(), null]),
        undefined,
      ]),
      created: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
      text: faker.string.alpha(20),
    })),
    undefined,
  ]),
  conclusion: {
    uid: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.uuid(), null]),
      undefined,
    ]),
    created: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated: `${faker.date.past().toISOString().split(".")[0]}Z`,
    text: faker.string.alpha(20),
  },
  valid: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getAuthJwtLoginAuthJwtLoginPostResponseMock = (
  overrideResponse: Partial<BearerResponse> = {},
): BearerResponse => ({
  access_token: faker.string.alpha(20),
  token_type: faker.string.alpha(20),
  ...overrideResponse,
});

export const getRegisterRegisterAuthRegisterPostResponseMock = (
  overrideResponse: Partial<UserRead> = {},
): UserRead => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  is_superuser: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  is_verified: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  ...overrideResponse,
});

export const getVerifyVerifyAuthVerifyPostResponseMock = (
  overrideResponse: Partial<UserRead> = {},
): UserRead => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  is_superuser: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  is_verified: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  ...overrideResponse,
});

export const getOauthGoogleJwtAuthorizeGoogleAuthorizeGetResponseMock = (
  overrideResponse: Partial<OAuth2AuthorizeResponse> = {},
): OAuth2AuthorizeResponse => ({
  authorization_url: faker.string.alpha(20),
  ...overrideResponse,
});

export const getUsersCurrentUserUserMeGetResponseMock = (
  overrideResponse: Partial<UserRead> = {},
): UserRead => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  is_superuser: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  is_verified: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  ...overrideResponse,
});

export const getUsersPatchCurrentUserUserMePatchResponseMock = (
  overrideResponse: Partial<UserRead> = {},
): UserRead => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  is_superuser: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  is_verified: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  ...overrideResponse,
});

export const getUsersUserUserIdGetResponseMock = (
  overrideResponse: Partial<UserRead> = {},
): UserRead => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  is_superuser: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  is_verified: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  ...overrideResponse,
});

export const getUsersPatchUserUserIdPatchResponseMock = (
  overrideResponse: Partial<UserRead> = {},
): UserRead => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  is_superuser: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  is_verified: faker.helpers.arrayElement([
    faker.datatype.boolean(),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetNamaspaceNamespaceGetResponseMock = (
  overrideResponse: Partial<NameSpace> = {},
): NameSpace => ({
  g: faker.helpers.arrayElement([
    {
      directed: faker.datatype.boolean(),
      edges: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        source: faker.string.alpha(20),
        target: faker.string.alpha(20),
      })),
      graph: {},
      multigraph: faker.datatype.boolean(),
      nodes: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        [faker.string.alphanumeric(5)]: faker.string.alpha(20),
      })),
    },
    undefined,
  ]),
  roots_: {
    [faker.string.alphanumeric(5)]: {
      name: faker.string.alpha(20),
      element_id_property: faker.helpers.arrayElement([
        faker.helpers.arrayElement([faker.string.alpha(20), null]),
        undefined,
      ]),
      uid: faker.string.uuid(),
    },
  },
  user_id: faker.string.uuid(),
  ...overrideResponse,
});

export const getSyncPathsNamespacePostResponseMock = (): string[] =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, () =>
    faker.word.sample(),
  );

export const getSearchByTextKnowdeGetResponseMock = (): KAdjacency[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    center: {
      sentence: faker.string.alpha(20),
      uid: faker.string.uuid(),
      term: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          {
            names: faker.helpers.arrayElement([
              Array.from(
                { length: faker.number.int({ min: 1, max: 10 }) },
                (_, i) => i + 1,
              ).map(() => faker.string.alpha(20)),
              undefined,
            ]),
            alias: faker.helpers.arrayElement([
              faker.helpers.arrayElement([faker.string.alpha(20), null]),
              undefined,
            ]),
          },
          null,
        ]),
        undefined,
      ]),
    },
    when: faker.helpers.arrayElement([
      faker.helpers.arrayElement([faker.string.alpha(20), null]),
      undefined,
    ]),
    details: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        sentence: faker.string.alpha(20),
        uid: faker.string.uuid(),
        term: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            {
              names: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.string.alpha(20)),
                undefined,
              ]),
              alias: faker.helpers.arrayElement([
                faker.helpers.arrayElement([faker.string.alpha(20), null]),
                undefined,
              ]),
            },
            null,
          ]),
          undefined,
        ]),
      })),
      undefined,
    ]),
    premises: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        sentence: faker.string.alpha(20),
        uid: faker.string.uuid(),
        term: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            {
              names: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.string.alpha(20)),
                undefined,
              ]),
              alias: faker.helpers.arrayElement([
                faker.helpers.arrayElement([faker.string.alpha(20), null]),
                undefined,
              ]),
            },
            null,
          ]),
          undefined,
        ]),
      })),
      undefined,
    ]),
    conclusions: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        sentence: faker.string.alpha(20),
        uid: faker.string.uuid(),
        term: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            {
              names: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.string.alpha(20)),
                undefined,
              ]),
              alias: faker.helpers.arrayElement([
                faker.helpers.arrayElement([faker.string.alpha(20), null]),
                undefined,
              ]),
            },
            null,
          ]),
          undefined,
        ]),
      })),
      undefined,
    ]),
    refers: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        sentence: faker.string.alpha(20),
        uid: faker.string.uuid(),
        term: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            {
              names: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.string.alpha(20)),
                undefined,
              ]),
              alias: faker.helpers.arrayElement([
                faker.helpers.arrayElement([faker.string.alpha(20), null]),
                undefined,
              ]),
            },
            null,
          ]),
          undefined,
        ]),
      })),
      undefined,
    ]),
    referreds: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        sentence: faker.string.alpha(20),
        uid: faker.string.uuid(),
        term: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            {
              names: faker.helpers.arrayElement([
                Array.from(
                  { length: faker.number.int({ min: 1, max: 10 }) },
                  (_, i) => i + 1,
                ).map(() => faker.string.alpha(20)),
                undefined,
              ]),
              alias: faker.helpers.arrayElement([
                faker.helpers.arrayElement([faker.string.alpha(20), null]),
                undefined,
              ]),
            },
            null,
          ]),
          undefined,
        ]),
      })),
      undefined,
    ]),
    stats: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        {
          n_detail: faker.number.int({ min: undefined, max: undefined }),
          n_premise: faker.number.int({ min: undefined, max: undefined }),
          n_conclusion: faker.number.int({ min: undefined, max: undefined }),
          n_refer: faker.number.int({ min: undefined, max: undefined }),
          n_referred: faker.number.int({ min: undefined, max: undefined }),
          dist_axiom: faker.number.int({ min: undefined, max: undefined }),
          dist_leaf: faker.number.int({ min: undefined, max: undefined }),
          score: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              null,
            ]),
            undefined,
          ]),
        },
        null,
      ]),
      undefined,
    ]),
  }));

export const getCheckHealthHealthGetResponseMock = (): string =>
  faker.word.sample();

export const getListDefinitionsDefinitionGetMockHandler = (
  overrideResponse?:
    | StatsDefinitions
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<StatsDefinitions> | StatsDefinitions),
) => {
  return http.get("*/definition", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getListDefinitionsDefinitionGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getAddDefinitionDefinitionPostMockHandler = (
  overrideResponse?:
    | Definition
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Definition> | Definition),
) => {
  return http.post("*/definition", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getAddDefinitionDefinitionPostResponseMock(),
      ),
      { status: 201, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getCompleteDefinitionDefinitionCompletionGetMockHandler = (
  overrideResponse?:
    | Definition
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Definition> | Definition),
) => {
  return http.get("*/definition/completion", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCompleteDefinitionDefinitionCompletionGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getDetailServiceDefinitionDefUidGetMockHandler = (
  overrideResponse?:
    | DetailView
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<DetailView> | DetailView),
) => {
  return http.get("*/definition/:defUid", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getDetailServiceDefinitionDefUidGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getRemoveDefinitionDefinitionDefUidDeleteMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
) => {
  return http.delete("*/definition/:defUid", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 204 });
  });
};

export const getListPropositionsPropositionGetMockHandler = (
  overrideResponse?:
    | Proposition[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Proposition[]> | Proposition[]),
) => {
  return http.get("*/proposition", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getListPropositionsPropositionGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getAddPropositionPropositionPostMockHandler = (
  overrideResponse?:
    | unknown
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<unknown> | unknown),
) => {
  return http.post("*/proposition", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 201 });
  });
};

export const getCompletePropositionPropositionCompletionGetMockHandler = (
  overrideResponse?:
    | Proposition
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Proposition> | Proposition),
) => {
  return http.get("*/proposition/completion", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCompletePropositionPropositionCompletionGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getChangePropositionPropositionUidPutMockHandler = (
  overrideResponse?:
    | unknown
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<unknown> | unknown),
) => {
  return http.put("*/proposition/:uid", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 200 });
  });
};

export const getDeletePropositionPropositionUidDeleteMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
) => {
  return http.delete("*/proposition/:uid", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 204 });
  });
};

export const getListDeductionsDeductionGetMockHandler = (
  overrideResponse?:
    | StatsDeductions
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<StatsDeductions> | StatsDeductions),
) => {
  return http.get("*/deduction", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getListDeductionsDeductionGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getDeductDeductionPostMockHandler = (
  overrideResponse?:
    | Deduction
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Deduction> | Deduction),
) => {
  return http.post("*/deduction", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getDeductDeductionPostResponseMock(),
      ),
      { status: 201, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getCompleteDeductionMapperDeductionCompletionGetMockHandler = (
  overrideResponse?:
    | DeductionMapper
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<DeductionMapper> | DeductionMapper),
) => {
  return http.get("*/deduction/completion", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCompleteDeductionMapperDeductionCompletionGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getRemoveDeductionDeductionUidDeleteMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
) => {
  return http.delete("*/deduction/:uid", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 204 });
  });
};

export const getReplacePremisesDeductionUidPremisesPutMockHandler = (
  overrideResponse?:
    | Deduction
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<Deduction> | Deduction),
) => {
  return http.put("*/deduction/:uid/premises", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getReplacePremisesDeductionUidPremisesPutResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getReplaceConclusionDeductionUidConclusionPutMockHandler = (
  overrideResponse?:
    | Deduction
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<Deduction> | Deduction),
) => {
  return http.put("*/deduction/:uid/conclusion", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getReplaceConclusionDeductionUidConclusionPutResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getAuthJwtLoginAuthJwtLoginPostMockHandler = (
  overrideResponse?:
    | BearerResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<BearerResponse> | BearerResponse),
) => {
  return http.post("*/auth/jwt/login", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getAuthJwtLoginAuthJwtLoginPostResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getAuthJwtLogoutAuthJwtLogoutPostMockHandler = (
  overrideResponse?:
    | unknown
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<unknown> | unknown),
) => {
  return http.post("*/auth/jwt/logout", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 200 });
  });
};

export const getRegisterRegisterAuthRegisterPostMockHandler = (
  overrideResponse?:
    | UserRead
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<UserRead> | UserRead),
) => {
  return http.post("*/auth/register", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRegisterRegisterAuthRegisterPostResponseMock(),
      ),
      { status: 201, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getResetForgotPasswordAuthForgotPasswordPostMockHandler = (
  overrideResponse?:
    | unknown
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<unknown> | unknown),
) => {
  return http.post("*/auth/forgot-password", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 202 });
  });
};

export const getResetResetPasswordAuthResetPasswordPostMockHandler = (
  overrideResponse?:
    | unknown
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<unknown> | unknown),
) => {
  return http.post("*/auth/reset-password", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 200 });
  });
};

export const getVerifyRequestTokenAuthRequestVerifyTokenPostMockHandler = (
  overrideResponse?:
    | unknown
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<unknown> | unknown),
) => {
  return http.post("*/auth/request-verify-token", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 202 });
  });
};

export const getVerifyVerifyAuthVerifyPostMockHandler = (
  overrideResponse?:
    | UserRead
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<UserRead> | UserRead),
) => {
  return http.post("*/auth/verify", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getVerifyVerifyAuthVerifyPostResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getOauthGoogleJwtAuthorizeGoogleAuthorizeGetMockHandler = (
  overrideResponse?:
    | OAuth2AuthorizeResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<OAuth2AuthorizeResponse> | OAuth2AuthorizeResponse),
) => {
  return http.get("*/google/authorize", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getOauthGoogleJwtAuthorizeGoogleAuthorizeGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getOauthGoogleJwtCallbackGoogleCallbackGetMockHandler = (
  overrideResponse?:
    | unknown
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<unknown> | unknown),
) => {
  return http.get("*/google/callback", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 200 });
  });
};

export const getUsersCurrentUserUserMeGetMockHandler = (
  overrideResponse?:
    | UserRead
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<UserRead> | UserRead),
) => {
  return http.get("*/user/me", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUsersCurrentUserUserMeGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getUsersPatchCurrentUserUserMePatchMockHandler = (
  overrideResponse?:
    | UserRead
    | ((
        info: Parameters<Parameters<typeof http.patch>[1]>[0],
      ) => Promise<UserRead> | UserRead),
) => {
  return http.patch("*/user/me", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUsersPatchCurrentUserUserMePatchResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getUsersUserUserIdGetMockHandler = (
  overrideResponse?:
    | UserRead
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<UserRead> | UserRead),
) => {
  return http.get("*/user/:id", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUsersUserUserIdGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getUsersPatchUserUserIdPatchMockHandler = (
  overrideResponse?:
    | UserRead
    | ((
        info: Parameters<Parameters<typeof http.patch>[1]>[0],
      ) => Promise<UserRead> | UserRead),
) => {
  return http.patch("*/user/:id", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUsersPatchUserUserIdPatchResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getUsersDeleteUserUserIdDeleteMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<void> | void),
) => {
  return http.delete("*/user/:id", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 204 });
  });
};

export const getGetNamaspaceNamespaceGetMockHandler = (
  overrideResponse?:
    | NameSpace
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<NameSpace> | NameSpace),
) => {
  return http.get("*/namespace", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetNamaspaceNamespaceGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getSyncPathsNamespacePostMockHandler = (
  overrideResponse?:
    | string[]
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<string[]> | string[]),
) => {
  return http.post("*/namespace", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSyncPathsNamespacePostResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getReadFileUploadPostMockHandler = (
  overrideResponse?:
    | null
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<null> | null),
) => {
  return http.post("*/upload", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 200 });
  });
};

export const getSearchByTextKnowdeGetMockHandler = (
  overrideResponse?:
    | KAdjacency[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<KAdjacency[]> | KAdjacency[]),
) => {
  return http.get("*/knowde/", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchByTextKnowdeGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getCheckHealthHealthGetMockHandler = (
  overrideResponse?:
    | string
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<string> | string),
) => {
  return http.get("*/health", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCheckHealthHealthGetResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};
export const getFastAPIMock = () => [
  getListDefinitionsDefinitionGetMockHandler(),
  getAddDefinitionDefinitionPostMockHandler(),
  getCompleteDefinitionDefinitionCompletionGetMockHandler(),
  getDetailServiceDefinitionDefUidGetMockHandler(),
  getRemoveDefinitionDefinitionDefUidDeleteMockHandler(),
  getListPropositionsPropositionGetMockHandler(),
  getAddPropositionPropositionPostMockHandler(),
  getCompletePropositionPropositionCompletionGetMockHandler(),
  getChangePropositionPropositionUidPutMockHandler(),
  getDeletePropositionPropositionUidDeleteMockHandler(),
  getListDeductionsDeductionGetMockHandler(),
  getDeductDeductionPostMockHandler(),
  getCompleteDeductionMapperDeductionCompletionGetMockHandler(),
  getRemoveDeductionDeductionUidDeleteMockHandler(),
  getReplacePremisesDeductionUidPremisesPutMockHandler(),
  getReplaceConclusionDeductionUidConclusionPutMockHandler(),
  getAuthJwtLoginAuthJwtLoginPostMockHandler(),
  getAuthJwtLogoutAuthJwtLogoutPostMockHandler(),
  getRegisterRegisterAuthRegisterPostMockHandler(),
  getResetForgotPasswordAuthForgotPasswordPostMockHandler(),
  getResetResetPasswordAuthResetPasswordPostMockHandler(),
  getVerifyRequestTokenAuthRequestVerifyTokenPostMockHandler(),
  getVerifyVerifyAuthVerifyPostMockHandler(),
  getOauthGoogleJwtAuthorizeGoogleAuthorizeGetMockHandler(),
  getOauthGoogleJwtCallbackGoogleCallbackGetMockHandler(),
  getUsersCurrentUserUserMeGetMockHandler(),
  getUsersPatchCurrentUserUserMePatchMockHandler(),
  getUsersUserUserIdGetMockHandler(),
  getUsersPatchUserUserIdPatchMockHandler(),
  getUsersDeleteUserUserIdDeleteMockHandler(),
  getGetNamaspaceNamespaceGetMockHandler(),
  getSyncPathsNamespacePostMockHandler(),
  getReadFileUploadPostMockHandler(),
  getSearchByTextKnowdeGetMockHandler(),
  getCheckHealthHealthGetMockHandler(),
];
